// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: types.go

package model

import (
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

// MarshalJSON marshal bytes to json - template
func (j *ParsedMessage) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ParsedMessage) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "fields":`)

	{

		err = j.Fields.MarshalJSONBuf(buf)
		if err != nil {
			return err
		}

	}
	buf.WriteByte(',')
	if len(j.Client) != 0 {
		buf.WriteString(`"client":`)
		fflib.WriteJsonString(buf, string(j.Client))
		buf.WriteByte(',')
	}
	buf.WriteString(`"local_port":"`)
	fflib.FormatBits2(buf, uint64(j.LocalPort), 10, j.LocalPort < 0)
	buf.WriteString(`",`)
	if len(j.UnixSocketPath) != 0 {
		buf.WriteString(`"unix_socket_path":`)
		fflib.WriteJsonString(buf, string(j.UnixSocketPath))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *SyslogMessage) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *SyslogMessage) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "priority":"`)
	fflib.FormatBits2(buf, uint64(j.Priority), 10, j.Priority < 0)
	buf.WriteString(`","facility":"`)
	fflib.FormatBits2(buf, uint64(j.Facility), 10, j.Facility < 0)
	buf.WriteString(`","severity":"`)
	fflib.FormatBits2(buf, uint64(j.Severity), 10, j.Severity < 0)
	buf.WriteString(`","version":"`)
	fflib.FormatBits2(buf, uint64(j.Version), 10, j.Version < 0)
	buf.WriteString(`","timereported":`)
	fflib.WriteJsonString(buf, string(j.TimeReported))
	buf.WriteString(`,"timegenerated":`)
	fflib.WriteJsonString(buf, string(j.TimeGenerated))
	buf.WriteString(`,"hostname":`)
	fflib.WriteJsonString(buf, string(j.Hostname))
	buf.WriteString(`,"appname":`)
	fflib.WriteJsonString(buf, string(j.Appname))
	buf.WriteByte(',')
	if len(j.Procid) != 0 {
		buf.WriteString(`"procid":`)
		fflib.WriteJsonString(buf, string(j.Procid))
		buf.WriteByte(',')
	}
	if len(j.Msgid) != 0 {
		buf.WriteString(`"msgid":`)
		fflib.WriteJsonString(buf, string(j.Msgid))
		buf.WriteByte(',')
	}
	if len(j.Structured) != 0 {
		buf.WriteString(`"structured":`)
		fflib.WriteJsonString(buf, string(j.Structured))
		buf.WriteByte(',')
	}
	buf.WriteString(`"message":`)
	fflib.WriteJsonString(buf, string(j.Message))
	buf.WriteByte(',')
	if len(j.Properties) != 0 {
		buf.WriteString(`"properties":`)
		/* Falling back. type=map[string]map[string]string kind=map */
		err = buf.Encode(j.Properties)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}
