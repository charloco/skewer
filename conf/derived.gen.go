// Code generated by goderive DO NOT EDIT.

package conf

// deriveCloneBaseConfig returns a clone of the src parameter.
func deriveCloneBaseConfig(src BaseConfig) BaseConfig {
	dst := new(BaseConfig)
	deriveDeepCopy(dst, &src)
	return *dst
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *BaseConfig) {
	if src.TcpSource == nil {
		dst.TcpSource = nil
	} else {
		if dst.TcpSource != nil {
			if len(src.TcpSource) > len(dst.TcpSource) {
				if cap(dst.TcpSource) >= len(src.TcpSource) {
					dst.TcpSource = (dst.TcpSource)[:len(src.TcpSource)]
				} else {
					dst.TcpSource = make([]TcpSourceConfig, len(src.TcpSource))
				}
			} else if len(src.TcpSource) < len(dst.TcpSource) {
				dst.TcpSource = (dst.TcpSource)[:len(src.TcpSource)]
			}
		} else {
			dst.TcpSource = make([]TcpSourceConfig, len(src.TcpSource))
		}
		deriveDeepCopy_(dst.TcpSource, src.TcpSource)
	}
	if src.UdpSource == nil {
		dst.UdpSource = nil
	} else {
		if dst.UdpSource != nil {
			if len(src.UdpSource) > len(dst.UdpSource) {
				if cap(dst.UdpSource) >= len(src.UdpSource) {
					dst.UdpSource = (dst.UdpSource)[:len(src.UdpSource)]
				} else {
					dst.UdpSource = make([]UdpSourceConfig, len(src.UdpSource))
				}
			} else if len(src.UdpSource) < len(dst.UdpSource) {
				dst.UdpSource = (dst.UdpSource)[:len(src.UdpSource)]
			}
		} else {
			dst.UdpSource = make([]UdpSourceConfig, len(src.UdpSource))
		}
		deriveDeepCopy_1(dst.UdpSource, src.UdpSource)
	}
	if src.RelpSource == nil {
		dst.RelpSource = nil
	} else {
		if dst.RelpSource != nil {
			if len(src.RelpSource) > len(dst.RelpSource) {
				if cap(dst.RelpSource) >= len(src.RelpSource) {
					dst.RelpSource = (dst.RelpSource)[:len(src.RelpSource)]
				} else {
					dst.RelpSource = make([]RelpSourceConfig, len(src.RelpSource))
				}
			} else if len(src.RelpSource) < len(dst.RelpSource) {
				dst.RelpSource = (dst.RelpSource)[:len(src.RelpSource)]
			}
		} else {
			dst.RelpSource = make([]RelpSourceConfig, len(src.RelpSource))
		}
		deriveDeepCopy_2(dst.RelpSource, src.RelpSource)
	}
	dst.Store = src.Store
	if src.Parsers == nil {
		dst.Parsers = nil
	} else {
		if dst.Parsers != nil {
			if len(src.Parsers) > len(dst.Parsers) {
				if cap(dst.Parsers) >= len(src.Parsers) {
					dst.Parsers = (dst.Parsers)[:len(src.Parsers)]
				} else {
					dst.Parsers = make([]ParserConfig, len(src.Parsers))
				}
			} else if len(src.Parsers) < len(dst.Parsers) {
				dst.Parsers = (dst.Parsers)[:len(src.Parsers)]
			}
		} else {
			dst.Parsers = make([]ParserConfig, len(src.Parsers))
		}
		copy(dst.Parsers, src.Parsers)
	}
	dst.Journald = src.Journald
	dst.Metrics = src.Metrics
	dst.Accounting = src.Accounting
	dst.Main = src.Main
	field := new(KafkaDestConfig)
	deriveDeepCopy_3(field, &src.KafkaDest)
	dst.KafkaDest = *field
	dst.UdpDest = src.UdpDest
	dst.TcpDest = src.TcpDest
	dst.RelpDest = src.RelpDest
	dst.FileDest = src.FileDest
	dst.StderrDest = src.StderrDest
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src []TcpSourceConfig) {
	for src_i, src_value := range src {
		field := new(TcpSourceConfig)
		deriveDeepCopy_4(field, &src_value)
		dst[src_i] = *field
	}
}

// deriveDeepCopy_1 recursively copies the contents of src into dst.
func deriveDeepCopy_1(dst, src []UdpSourceConfig) {
	for src_i, src_value := range src {
		field := new(UdpSourceConfig)
		deriveDeepCopy_5(field, &src_value)
		dst[src_i] = *field
	}
}

// deriveDeepCopy_2 recursively copies the contents of src into dst.
func deriveDeepCopy_2(dst, src []RelpSourceConfig) {
	for src_i, src_value := range src {
		field := new(RelpSourceConfig)
		deriveDeepCopy_6(field, &src_value)
		dst[src_i] = *field
	}
}

// deriveDeepCopy_3 recursively copies the contents of src into dst.
func deriveDeepCopy_3(dst, src *KafkaDestConfig) {
	dst.TlsBaseConfig = src.TlsBaseConfig
	dst.BaseDestConfig = src.BaseDestConfig
	dst.Insecure = src.Insecure
	if src.Brokers == nil {
		dst.Brokers = nil
	} else {
		if dst.Brokers != nil {
			if len(src.Brokers) > len(dst.Brokers) {
				if cap(dst.Brokers) >= len(src.Brokers) {
					dst.Brokers = (dst.Brokers)[:len(src.Brokers)]
				} else {
					dst.Brokers = make([]string, len(src.Brokers))
				}
			} else if len(src.Brokers) < len(dst.Brokers) {
				dst.Brokers = (dst.Brokers)[:len(src.Brokers)]
			}
		} else {
			dst.Brokers = make([]string, len(src.Brokers))
		}
		copy(dst.Brokers, src.Brokers)
	}
	dst.ClientID = src.ClientID
	dst.Version = src.Version
	dst.ChannelBufferSize = src.ChannelBufferSize
	dst.MaxOpenRequests = src.MaxOpenRequests
	dst.DialTimeout = src.DialTimeout
	dst.ReadTimeout = src.ReadTimeout
	dst.WriteTimeout = src.WriteTimeout
	dst.KeepAlive = src.KeepAlive
	dst.MetadataRetryMax = src.MetadataRetryMax
	dst.MetadataRetryBackoff = src.MetadataRetryBackoff
	dst.MetadataRefreshFrequency = src.MetadataRefreshFrequency
	dst.MessageBytesMax = src.MessageBytesMax
	dst.RequiredAcks = src.RequiredAcks
	dst.ProducerTimeout = src.ProducerTimeout
	dst.Compression = src.Compression
	dst.FlushBytes = src.FlushBytes
	dst.FlushMessages = src.FlushMessages
	dst.FlushFrequency = src.FlushFrequency
	dst.FlushMessagesMax = src.FlushMessagesMax
	dst.RetrySendMax = src.RetrySendMax
	dst.RetrySendBackoff = src.RetrySendBackoff
	dst.Partitioner = src.Partitioner
}

// deriveDeepCopy_4 recursively copies the contents of src into dst.
func deriveDeepCopy_4(dst, src *TcpSourceConfig) {
	field := new(SyslogSourceBaseConfig)
	deriveDeepCopy_7(field, &src.SyslogSourceBaseConfig)
	dst.SyslogSourceBaseConfig = *field
	dst.FilterSubConfig = src.FilterSubConfig
	dst.TlsBaseConfig = src.TlsBaseConfig
	dst.ClientAuthType = src.ClientAuthType
	dst.ConfID = src.ConfID
}

// deriveDeepCopy_5 recursively copies the contents of src into dst.
func deriveDeepCopy_5(dst, src *UdpSourceConfig) {
	field := new(SyslogSourceBaseConfig)
	deriveDeepCopy_7(field, &src.SyslogSourceBaseConfig)
	dst.SyslogSourceBaseConfig = *field
	dst.FilterSubConfig = src.FilterSubConfig
	dst.ConfID = src.ConfID
}

// deriveDeepCopy_6 recursively copies the contents of src into dst.
func deriveDeepCopy_6(dst, src *RelpSourceConfig) {
	field := new(SyslogSourceBaseConfig)
	deriveDeepCopy_7(field, &src.SyslogSourceBaseConfig)
	dst.SyslogSourceBaseConfig = *field
	dst.FilterSubConfig = src.FilterSubConfig
	dst.TlsBaseConfig = src.TlsBaseConfig
	dst.ClientAuthType = src.ClientAuthType
	dst.ConfID = src.ConfID
}

// deriveDeepCopy_7 recursively copies the contents of src into dst.
func deriveDeepCopy_7(dst, src *SyslogSourceBaseConfig) {
	if src.Ports == nil {
		dst.Ports = nil
	} else {
		if dst.Ports != nil {
			if len(src.Ports) > len(dst.Ports) {
				if cap(dst.Ports) >= len(src.Ports) {
					dst.Ports = (dst.Ports)[:len(src.Ports)]
				} else {
					dst.Ports = make([]int, len(src.Ports))
				}
			} else if len(src.Ports) < len(dst.Ports) {
				dst.Ports = (dst.Ports)[:len(src.Ports)]
			}
		} else {
			dst.Ports = make([]int, len(src.Ports))
		}
		copy(dst.Ports, src.Ports)
	}
	dst.BindAddr = src.BindAddr
	dst.UnixSocketPath = src.UnixSocketPath
	dst.Format = src.Format
	dst.DontParseSD = src.DontParseSD
	dst.KeepAlive = src.KeepAlive
	dst.KeepAlivePeriod = src.KeepAlivePeriod
	dst.Timeout = src.Timeout
	dst.Encoding = src.Encoding
}
