// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package defered

import (
	"time"

	"github.com/stephane-martin/skewer/model"
	"github.com/stephane-martin/skewer/utils"
	"github.com/stephane-martin/skewer/utils/eerrors"
	"go.uber.org/atomic"
)

type node struct {
	position atomic.Uint64
	data     *model.DeferedRequest
}

func newNode(pos uint64) *node {
	var n node
	n.position.Store(pos)
	return &n
}

type nodes []*node

// Ring is a thread-safe bounded queue that stores *model.DeferedRequest messages.
type Ring struct {
	mask      uint64
	_padding0 [8]uint64
	queue     atomic.Uint64
	_padding1 [8]uint64
	dequeue   atomic.Uint64
	_padding2 [8]uint64
	disposed  atomic.Bool
	_padding3 [8]uint64
	nodes     nodes
}

func (rb *Ring) init(size uint64) {
	size = utils.RoundUp(size)
	rb.nodes = make(nodes, size)
	for i := uint64(0); i < size; i++ {
		rb.nodes[i] = newNode(i)
	}
	rb.mask = size - 1 // so we don't have to do this with every put/get operation
}

// Put adds the provided item to the queue.  If the queue is full, this
// call will block until an item is added to the queue or Dispose is called
// on the queue.  An error will be returned if the queue is disposed.
func (rb *Ring) Put(item *model.DeferedRequest) error {
	_, err := rb.put(item, false)
	return err
}

// Offer adds the provided item to the queue if there is space.  If the queue
// is full, this call will return false.  An error will be returned if the
// queue is disposed.
func (rb *Ring) Offer(item *model.DeferedRequest) (bool, error) {
	return rb.put(item, true)
}

func (rb *Ring) put(item *model.DeferedRequest, offer bool) (bool, error) {
	var (
		n *node
		w utils.ExpWait
	)
	pos := rb.queue.Load()
L:
	for {
		if rb.disposed.Load() {
			return false, eerrors.ErrQDisposed
		}

		n = rb.nodes[pos&rb.mask]
		seq := n.position.Load()
		switch dif := seq - pos; {
		case dif == 0:
			if rb.queue.CAS(pos, pos+1) {
				break L
			}
		case dif < 0:
			panic(`Ring buffer in a compromised state during a put operation.`)
		default:
			pos = rb.queue.Load()
		}

		if offer {
			return false, nil
		}

		w.Wait()
	}

	n.data = item
	n.position.Store(pos + 1)
	return true, nil
}

// Get will return the next item in the queue.  This call will block
// if the queue is empty.  This call will unblock when an item is added
// to the queue or Dispose is called on the queue.  An error will be returned
// if the queue is disposed.
func (rb *Ring) Get() (*model.DeferedRequest, error) {
	return rb.Poll(0)
}

func (rb *Ring) PollDeadline(deadline time.Time) (*model.DeferedRequest, error) {
	return rb.Poll(deadline.Sub(time.Now()))
}

// Poll will return the next item in the queue.  This call will block
// if the queue is empty.  This call will unblock when an item is added
// to the queue, Dispose is called on the queue, or the timeout is reached. An
// error will be returned if the queue is disposed or a timeout occurs. A
// non-positive timeout will block indefinitely.
func (rb *Ring) Poll(timeout time.Duration) (*model.DeferedRequest, error) {
	var (
		n     *node
		pos   = rb.dequeue.Load()
		start time.Time
		w     utils.ExpWait
		zero  *model.DeferedRequest
	)
	if timeout > 0 {
		start = time.Now()
	}
L:
	for {
		n = rb.nodes[pos&rb.mask]
		seq := n.position.Load()
		switch dif := seq - (pos + 1); {
		case dif == 0:
			if rb.dequeue.CAS(pos, pos+1) {
				break L
			}
		case dif < 0:
			panic(`Ring buffer in compromised state during a get operation.`)
		default:
			pos = rb.dequeue.Load()
		}

		if timeout > 0 && time.Since(start) >= timeout {
			return zero, eerrors.ErrQTimeout
		}
		if rb.disposed.Load() {
			return zero, eerrors.ErrQDisposed
		}
		w.Wait()
	}
	data := n.data
	n.data = zero
	n.position.Store(pos + rb.mask + 1)
	return data, nil
}

// Len returns the number of items in the queue.
func (rb *Ring) Len() uint64 {
	return rb.queue.Load() - rb.dequeue.Load()
}

// Cap returns the capacity of this ring buffer.
func (rb *Ring) Cap() uint64 {
	return uint64(len(rb.nodes))
}

// Dispose will dispose of this queue and free any blocked threads
// in the Put and/or Get methods.  Calling those methods on a disposed
// queue will return an error.
func (rb *Ring) Dispose() {
	rb.disposed.Store(true)
}

// IsDisposed will return a bool indicating if this queue has been
// disposed.
func (rb *Ring) IsDisposed() bool {
	return rb.disposed.Load()
}

// NewRing will allocate, initialize, and return a ring buffer
// with the specified size.
func NewRing(size uint64) *Ring {
	rb := &Ring{}
	rb.init(size)
	return rb
}
